#!/usr/bin/env python

from __future__ import annotations

from datetime import datetime
from typing import Any

import lib
from config import Config
from pytube import YouTube


def main(args: list | None = None):
    """
    Main function

    ### Command Line Arguments

    pythontube <video_url> [switch]...

    #### Switches

    - `-y`: Default flag to download video (lowest priority switch)
    - `--audio-only`: Download audio only
    - `--data-saver`: Download video in 720p or lower and/or audio in 128kbps or lower
    - `--timeout <seconds>`: Timeout for the download in seconds

    #### Examples

    `pythontube https://www.youtube.com/watch?v=Kp7eSUU9oy8 -y` # default arguments
    `pythontube https://www.youtube.com/watch?v=Kp7eSUU9oy8 --data-saver --audio-only --timeout 8`

    ### Note
    this script is working as of 26/05/2023
    """
    try:
        # prompt user for video url
        while True:
            if len(args) >= 1:
                if args[0].startswith("-"):
                    raise Exception("Invalid input")
                url = args[0]
                break
            else:
                url = input("Enter youtube link: ")
                if url != "":
                    break

        # needs to connect to your logged in Youtube Account
        yt_video = YouTube(url)
        # yt_video.bypass_age_gate()

        print_yt_video_info(yt_video)

        is_audio_only, is_data_saver, timeout = get_user_inputs(args)

        stream = lib.core.get_audio_only_stream(yt_video.streams, is_data_saver) if is_audio_only else lib.core.get_video_stream(
            yt_video.streams, is_data_saver)

        if stream:
            print(f"Stream metadata: {stream}\n")
            yt_video.register_on_progress_callback(
                get_on_progress_callback(stream.filesize))
            yt_video.register_on_complete_callback(on_complete)
            file_path = lib.core.download_stream(
                stream, Config("pythontube"), timeout)
            if file_path and is_audio_only:
                lib.core.convert_mp4_to_mp3(file_path)
    except KeyboardInterrupt:
        print("\n@@@ Exiting...")
        exit()


def print_yt_video_info(yt_video: YouTube):
    publish_date = datetime.strftime(yt_video.publish_date, '%b %d, %Y')
    video_length = lib.utils.format_second(yt_video.length)

    print("\n============================================================\n")
    print(f"  {yt_video.title}")
    print(f"  {yt_video.author}\n")
    print(
        f"  {yt_video.views} views - {publish_date}")
    print(f"  {video_length}")
    print("\n============================================================\n")


def get_user_inputs(args: list | None):
    # get download type
    while True:
        print("\nEnter download type (default: 1)")
        print("1. Video and audio")
        print("2. Audio only")
        if "--audio-only" in args:
            dt = 2
            print(f": {dt}")
        elif "-y" in args:
            dt = 1
            print(f": {dt}")
        else:
            dt_input = input(": ")
            dt = int(dt_input) if dt_input else 1
        if dt == 1:
            is_audio_only = False
        elif dt == 2:
            is_audio_only = True
        else:
            print("Invalid input\n")
            continue
        break

    # get download quality
    while True:
        print("\nEnter download quality (default: 1)")
        print("1. Highest quality")
        print("2. Data saver")
        if "--data-saver" in args:
            dq = 2
            print(f": {dq}")
        elif "-y" in args:
            dq = 1
            print(f": {dq}")
        else:
            dq_input = input(": ")
            dq = int(dq_input) if dq_input else 60
        if dq == 1:
            is_data_saver = False
        elif dq == 2:
            is_data_saver = True
        else:
            print("Invalid input\n")
            continue
        break

    # get download timeout
    print(f"\nEnter download timeout (default: 60)")
    if "-y" in args:
        timeout = 60
        print(f": {timeout}")
    elif "--timeout" in args:
        to_switch_index = args.index("--timeout")
        if to_switch_index + 1 >= len(args):
            raise Exception("Too few arguments")
        timeout = int(args[to_switch_index + 1])
        print(f": {timeout}")
    else:
        timeout_input = input(f": ")
        timeout = int(timeout_input) if timeout_input else 60
    print()
    return is_audio_only, is_data_saver, timeout


def get_on_progress_callback(stream_file_size: int):
    def on_progress(stream: Any, chunk: bytes, bytes_remaining: int):
        progress_percentage = 100 - (bytes_remaining / stream_file_size) * 100
        rounded_progress = round(progress_percentage, 2)
        progress_bar = f"[{'â–ˆ' * int(rounded_progress / 5):<20s}] {rounded_progress}%"
        print(f"\rProgress: {progress_bar}", end="")
        sys.stdout.flush()
    return on_progress


def on_complete(stream, file_path):
    print("@@@ Download complete!\n")
    print(f"File saved to: {file_path}")


if __name__ == '__main__':
    import sys
    main(sys.argv[1:])
